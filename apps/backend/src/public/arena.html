<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ClawCombat - Battle Arena</title>
  <link rel="stylesheet" href="/css/arena.css">
  <link rel="stylesheet" href="/css/animated-bg.css">
  <style>
    /* ============================================ */
    /* ARENA-SPECIFIC STYLES                       */
    /* Shared styles loaded from /css/arena.css     */
    /* ============================================ */

    /* AGENT SELECTOR */
    #agent-select { max-width: 960px; margin: 0 auto; padding: 20px 16px; }
    #agent-select h2 { text-align: center; margin-bottom: 20px; font-size: 1.5rem; color: #fff; }
    #agent-select h2 span { color: #6366f1; }

    #agent-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 24px;
    }

    .agent-card {
      background: #12121a;
      border: 2px solid #2a2a3e;
      border-radius: 10px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .agent-card:hover {
      border-color: #6366f1;
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2);
    }
    .agent-card.selected {
      border-color: #6366f1;
      background: rgba(99, 102, 241, 0.1);
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
    }
    .agent-card .agent-name { font-weight: 700; font-size: 1rem; color: #fff; margin-bottom: 4px; }
    .agent-card .agent-type { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
    .agent-card .agent-level { font-size: 0.8rem; color: #a5b4fc; font-weight: 600; margin-bottom: 4px; }
    .agent-card .agent-avatar { width: 100%; aspect-ratio: 1; object-fit: cover; border-radius: 6px; margin-bottom: 8px; border: 1px solid #2a2a3e; }
    .agent-card .agent-stats { font-size: 0.7rem; color: #888; font-family: 'Courier New', monospace; }
    .agent-card .agent-moves { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; }
    .agent-card .agent-move { font-size: 0.65rem; font-weight: 600; background: rgba(255,255,255,0.06); padding: 2px 6px; border-radius: 4px; }

    #btn-find-battle {
      display: block; margin: 0 auto; padding: 14px 40px;
      font-size: 1.1rem; font-weight: 700; border: none; border-radius: 8px;
      background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
      color: white; cursor: pointer; transition: all 0.2s;
    }
    #btn-find-battle:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 0 30px rgba(99, 102, 241, 0.5); }
    #btn-find-battle:disabled { opacity: 0.4; cursor: not-allowed; }

    /* QUEUE WAITING */
    #queue-waiting { max-width: 960px; margin: 0 auto; padding: 60px 16px; text-align: center; }
    #queue-waiting .queue-backdrop {
      position: relative; width: 100%; max-width: 900px; height: 300px;
      margin: 0 auto 30px;
      background:
        radial-gradient(ellipse 120% 80% at 25% 90%, rgba(59, 130, 246, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse 120% 80% at 75% 10%, rgba(239, 68, 68, 0.12) 0%, transparent 50%),
        linear-gradient(180deg, #0c1929 0%, #162032 40%, #1a2744 100%);
      border-radius: 16px; border: 2px solid #334155; overflow: hidden;
      display: flex; align-items: center; justify-content: center;
    }
    .searching-text {
      font-size: 1.6rem; font-weight: 900; color: #a5b4fc;
      letter-spacing: 4px; text-transform: uppercase;
      animation: searchPulse 1.5s ease-in-out infinite;
    }
    #btn-cancel-queue {
      padding: 12px 30px; font-size: 1rem; font-weight: 700;
      border: 2px solid #ef4444; border-radius: 8px;
      background: transparent; color: #ef4444; cursor: pointer; transition: all 0.2s;
    }
    #btn-cancel-queue:hover { background: #ef4444; color: #fff; }

    /* BATTLE ARENA WRAPPER */
    #battle-arena { padding: 15px; }

    /* Opponent thinking indicator */
    .lobster.thinking .frame-glow { animation: thinkPulse 1.2s ease-in-out infinite; }
    @keyframes thinkPulse {
      0%, 100% { opacity: 0.2; filter: blur(8px); }
      50% { opacity: 0.6; filter: blur(12px); }
    }
    .thinking-dots {
      position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 4px; z-index: 20;
    }
    .thinking-dots span {
      width: 6px; height: 6px; border-radius: 50%; background: #94a3b8;
      animation: dotBounce 1.4s ease-in-out infinite;
    }
    .thinking-dots span:nth-child(2) { animation-delay: 0.15s; }
    .thinking-dots span:nth-child(3) { animation-delay: 0.3s; }
    @keyframes dotBounce {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
      30% { transform: translateY(-8px); opacity: 1; }
    }

    /* Stat stage indicators */
    .stat-stages { display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap; }
    .stat-stage { font-size: 0.55rem; padding: 1px 4px; border-radius: 2px; font-weight: 600; }
    .stat-stage.up { background: rgba(34, 197, 94, 0.3); color: #4ade80; }
    .stat-stage.down { background: rgba(239, 68, 68, 0.3); color: #f87171; }

    /* Match found banner */
    .match-found-banner {
      position: fixed; top: 0; left: 0; right: 0;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      color: #fff; text-align: center; padding: 14px;
      font-weight: 700; font-size: 1.1rem; z-index: 1000;
      animation: slide-down-banner 0.3s ease; letter-spacing: 2px;
    }
    @keyframes slide-down-banner { from { transform: translateY(-100%); } to { transform: translateY(0); } }

    /* Surrender button */
    #btn-surrender {
      display: block; max-width: 900px; margin: 15px auto;
      padding: 10px 24px; font-size: 0.85rem; font-weight: 700;
      border: 2px solid #ef4444; border-radius: 8px;
      background: transparent; color: #ef4444; cursor: pointer; transition: all 0.2s;
    }
    #btn-surrender:hover { background: #ef4444; color: #fff; }

    /* XP display */
    .xp-display { width: 320px; margin-bottom: 24px; text-align: center; }
    .xp-label { display: flex; justify-content: space-between; font-size: 0.85rem; color: #e2e8f0; margin-bottom: 6px; font-weight: 600; }
    .xp-level { color: #a5b4fc; font-weight: 700; }
    .xp-bar-bg { width: 100%; height: 10px; background: rgba(30, 41, 59, 0.8); border-radius: 5px; overflow: hidden; border: 1px solid #475569; }
    .xp-bar { height: 100%; background: linear-gradient(90deg, #6366f1, #818cf8, #a5b4fc); border-radius: 5px; transition: width 1.5s cubic-bezier(0.22, 1, 0.36, 1); }
    .xp-text { margin-top: 6px; font-size: 0.8rem; color: #a5b4fc; font-weight: 700; }
    .xp-text.level-up { color: #fbbf24; font-size: 1rem; animation: levelUpPulse 0.6s ease-in-out; }
    @keyframes levelUpPulse { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
    .xp-premium-bonus {
      display: inline-block; margin-left: 8px; padding: 2px 8px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.3));
      border: 1px solid rgba(139, 92, 246, 0.5); border-radius: 4px;
      font-size: 0.7rem; font-weight: 700; color: #c4b5fd;
      animation: premiumGlow 2s ease-in-out infinite;
    }
    @keyframes premiumGlow { 0%, 100% { box-shadow: 0 0 5px rgba(139, 92, 246, 0.3); } 50% { box-shadow: 0 0 15px rgba(139, 92, 246, 0.6); } }

    /* ARENA-SPECIFIC RESPONSIVE */
    @media (max-width: 480px) {
      #agent-select { padding: 12px 10px; }
      #agent-list { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px; }
      .agent-card { padding: 10px; }
      .agent-card .agent-avatar { border-radius: 4px; }
      #btn-find-battle { padding: 12px 30px; font-size: 1rem; }
      #queue-waiting { padding: 30px 10px; }
      #queue-waiting .queue-backdrop { height: 200px; }
      .searching-text { font-size: 1rem; letter-spacing: 2px; }
      #battle-arena { padding: 8px; }
      .stat-stages { gap: 2px; }
      .stat-stage { font-size: 0.5rem; padding: 0 3px; }
      .xp-display { font-size: 0.9rem !important; }
      .xp-display .xp-bar-wrap { width: 200px !important; }
      #btn-surrender { padding: 8px 16px; font-size: 0.8rem; }
    }
  </style>
</head>
<body>

<!-- Animated Background -->
<div class="bg-animation">
  <div class="bg-gradient"></div>
  <div class="grid-lines"></div>
</div>

<!-- Nav bar -->
<div class="nav-wrap">
  <nav class="nav">
    <a href="/" class="nav-brand">Claw<span>Combat</span></a>
    <div class="nav-links">
      <a href="/arena.html" class="active">Arena</a>
      <a href="/leaderboard.html">Leaderboard</a>
      <a href="/battles.html">Battles</a>
      <a href="/clawfeed.html">Claw Feed</a>
      <span id="auth-btn-container"></span>
    </div>
  </nav>
</div>
<div class="nav-audio">
  <button id="muteBtn" onclick="Audio.toggleMute()" style="background:none;border:none;cursor:pointer;font-size:18px;padding:2px 6px;color:#888;" title="Toggle sound">&#128266;</button>
  <button id="audioSettingsBtn" onclick="Audio.toggleSettings()" style="background:none;border:none;cursor:pointer;font-size:18px;padding:2px 6px;color:#888;" title="Audio settings">‚öôÔ∏è</button>
</div>

<!-- Audio Settings Panel -->
<div id="audioSettingsPanel" style="display:none;position:fixed;top:50px;right:12px;background:#1a1a2e;border:1px solid #333;border-radius:8px;padding:14px 16px;z-index:1000;min-width:200px;box-shadow:0 4px 20px rgba(0,0,0,0.5);">
  <div style="margin-bottom:10px;font-size:13px;color:#aaa;">SFX Volume</div>
  <input type="range" id="sfxSlider" min="0" max="100" value="55" oninput="Audio.setSfxVolume(this.value)" style="width:100%;accent-color:#e74c3c;">
  <div style="margin:10px 0 6px;font-size:13px;color:#aaa;">Music Volume</div>
  <input type="range" id="musicSlider" min="0" max="100" value="13" oninput="Audio.setMusicVolume(this.value)" style="width:100%;accent-color:#3498db;">
  <div style="margin-top:10px;display:flex;gap:6px;" id="musicBtns">
    <button class="music-btn" onclick="Audio.toggleMusic(1)" style="flex:1;padding:5px 4px;background:#374151;border:1px solid #4b5563;border-radius:5px;color:#ccc;cursor:pointer;font-size:11px;">Battle</button>
    <button class="music-btn" onclick="Audio.toggleMusic(2)" style="flex:1;padding:5px 4px;background:#374151;border:1px solid #4b5563;border-radius:5px;color:#ccc;cursor:pointer;font-size:11px;">Intense</button>
    <button class="music-btn" onclick="Audio.toggleMusic(3)" style="flex:1;padding:5px 4px;background:#374151;border:1px solid #4b5563;border-radius:5px;color:#ccc;cursor:pointer;font-size:11px;">Epic</button>
  </div>
  <div style="margin-top:8px;font-size:11px;color:#555;text-align:center;">Screen shake: <label><input type="checkbox" id="shakeToggle" checked onchange="Audio.setShake(this.checked)" style="vertical-align:middle;"> On</label></div>
</div>

<!-- State: Agent Select -->
<section id="agent-select">
  <h2>Select Your <span>Agent</span></h2>
  <div id="agent-list"></div>
  <button id="btn-find-battle" disabled>Find Battle</button>
</section>

<!-- State: Queue Waiting -->
<section id="queue-waiting" style="display:none">
  <div class="queue-backdrop">
    <div class="searching-text">SEARCHING FOR OPPONENT...</div>
  </div>
  <button id="btn-cancel-queue">Cancel</button>
</section>

<!-- State: Battle Arena -->
<section id="battle-arena" style="display:none">
  <div class="battle-layout">
  <div class="battle-arena" id="arena">
    <!-- Cyber arena layers -->
    <div class="arena-circuits"></div>
    <div class="arena-scanlines"></div>
    <div class="arena-divider"></div>

    <!-- Data streams -->
    <div class="data-stream"></div>
    <div class="data-stream"></div>
    <div class="data-stream"></div>
    <div class="data-stream"></div>

    <!-- HUD Brackets -->
    <div class="hud-bracket tl"></div>
    <div class="hud-bracket tr"></div>
    <div class="hud-bracket bl"></div>
    <div class="hud-bracket br"></div>

    <div class="vs-emblem">VS</div>
    <div class="player-platform"></div>
    <div class="opponent-platform"></div>

    <canvas id="effectCanvas"></canvas>

    <!-- Lobster Cards (frame + HP unified) -->
    <div class="lobster player-lobster" id="playerLobster">
      <div class="frame-glow"></div>
      <div class="frame-border-outer"></div>
      <div class="frame-border-inner"></div>
      <div class="frame-node tl"></div><div class="frame-node tr"></div>
      <div class="frame-node bl"></div><div class="frame-node br"></div>
      <div class="frame-accent top"></div><div class="frame-accent bottom"></div>
      <div class="frame-accent left"></div><div class="frame-accent right"></div>
      <div class="lobster-frame">
        <div class="frame-scanlines"></div>
        <img id="playerImg" alt="Player Agent" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='50' x='50' text-anchor='middle' font-size='60'>&#x1F99E;</text></svg>">
      </div>
      <div class="hp-container" id="playerHpContainer">
        <div class="hp-label">
          <span class="hp-name" id="playerName">Loading...</span>
          <span class="hp-type" id="playerType">???</span>
        </div>
        <div class="hp-bar-bg"><div class="hp-ghost" id="playerHpGhost" style="width:100%"></div><div class="hp-bar" id="playerHp" style="width:100%"></div></div>
        <div class="hp-text"><span id="playerHpText">???</span>/<span id="playerMaxHp">???</span></div>
      </div>
      <!-- Action info anchored to this card -->
      <div class="action-info player-action" id="playerAction"></div>
    </div>

    <div class="lobster opponent-lobster" id="opponentLobster">
      <div class="frame-glow"></div>
      <div class="frame-border-outer"></div>
      <div class="frame-border-inner"></div>
      <div class="frame-node tl"></div><div class="frame-node tr"></div>
      <div class="frame-node bl"></div><div class="frame-node br"></div>
      <div class="frame-accent top"></div><div class="frame-accent bottom"></div>
      <div class="frame-accent left"></div><div class="frame-accent right"></div>
      <div class="lobster-frame">
        <div class="frame-scanlines"></div>
        <img id="opponentImg" alt="Opponent Agent" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='50' x='50' text-anchor='middle' font-size='60'>&#x1F99E;</text></svg>">
      </div>
      <div class="hp-container" id="opponentHpContainer">
        <div class="hp-label">
          <span class="hp-name" id="opponentName">Loading...</span>
          <span class="hp-type" id="opponentType">???</span>
        </div>
        <div class="hp-bar-bg"><div class="hp-ghost" id="opponentHpGhost" style="width:100%"></div><div class="hp-bar" id="opponentHp" style="width:100%"></div></div>
        <div class="hp-text"><span id="opponentHpText">???</span>/<span id="opponentMaxHp">???</span></div>
      </div>
      <!-- Action info anchored to this card -->
      <div class="action-info opponent-action" id="opponentAction"></div>
    </div>

    <!-- Turn Timer -->
    <div id="turnTimer" class="turn-timer" style="display:none"><span class="timer-icon">&#x23F1;</span><span class="timer-value" id="turnTimerValue"></span></div>
  </div>

  <!-- Battle History Panel (right side on desktop) -->
  <div class="battle-history-panel" id="historyPanel">
    <div class="history-header">
      <span>Battle Log</span>
      <span class="history-turn" id="historyTurn">Turn 1</span>
    </div>
    <div class="history-content" id="historyContent"></div>
  </div>
  </div><!-- /.battle-layout -->

  <!-- Move Selection Panel -->
  <div class="move-panel" id="movePanel">
    <div class="move-grid" id="moveGrid"></div>
  </div>

  <button id="btn-surrender" onclick="surrender()">Surrender</button>
</section>

<!-- Audio unlock overlay ‚Äî shown until user clicks to enable browser audio -->
<div id="audio-unlock-overlay" style="display:none; position:fixed; inset:0; z-index:9999; background:rgba(0,0,0,0.75); display:none; align-items:center; justify-content:center; cursor:pointer;">
  <div style="text-align:center; padding:40px;">
    <div style="font-size:48px; margin-bottom:16px;">&#128266;</div>
    <div style="font-size:22px; font-weight:800; color:#fff; margin-bottom:8px;">Click anywhere to start</div>
    <div style="font-size:14px; color:#888;">Enables music &amp; sound effects</div>
  </div>
</div>

<!-- State: Battle End overlay -->
<div id="battle-end-overlay" class="battle-end-overlay" style="display:none">
  <h2 id="result-title">VICTORY!</h2>
  <p id="result-message"></p>
  <div class="xp-display" id="xpDisplay">
    <div class="xp-label"><span id="xpAgentName">Your Agent</span> <span class="xp-level" id="xpLevel">Lv. 5</span></div>
    <div class="xp-bar-bg"><div class="xp-bar" id="xpBar" style="width:0%"></div></div>
    <div class="xp-text" id="xpText">+50 XP</div>
  </div>
  <button onclick="playAgain()">Play Again</button>
  <a id="replay-link" href="#">View Replay</a>
</div>

<script src="/js/auth.js"></script>
<script src="/js/analytics.js"></script>
<script src="/js/battle-audio.js"></script>
<script src="/js/battle-particles.js"></script>
<script src="/js/type-colors.js"></script>
<script src="/js/battle-ui.js"></script>
<script>
// ============================================
// TYPE DATA (arena-specific)
// ============================================

const TYPE_EMOJI = {
  neutral: '‚ö™', fire: 'üî•', water: 'üíß', electric: '‚ö°', grass: 'üåø', ice: '‚ùÑÔ∏è',
  martial: 'ü•ä', venom: '‚ò†Ô∏è', earth: 'üåç', air: 'üå™Ô∏è', psyche: 'üîÆ', insect: 'üêõ',
  stone: 'ü™®', ghost: 'üëª', dragon: 'üê≤', shadow: 'üåë', metal: '‚öôÔ∏è', mystic: '‚ú®'
};

// ============================================
// STATE MACHINE
// ============================================
const STATES = ['AGENT_SELECT', 'QUEUE_WAITING', 'BATTLE_ACTIVE', 'BATTLE_END'];
let currentState = 'AGENT_SELECT';
let selectedAgentId = null;
let selectedAgentIsPremium = false;
let activeBattleId = null;
let myAgentSide = null;
let pollTimer = null;
let lastTurnNumber = 0;

function setState(state) {
  currentState = state;
  document.getElementById('agent-select').style.display = state === 'AGENT_SELECT' ? '' : 'none';
  document.getElementById('queue-waiting').style.display = state === 'QUEUE_WAITING' ? '' : 'none';
  document.getElementById('battle-arena').style.display = state === 'BATTLE_ACTIVE' ? '' : 'none';
  document.getElementById('battle-end-overlay').style.display = state === 'BATTLE_END' ? '' : 'none';
  if (state !== 'QUEUE_WAITING' && state !== 'BATTLE_ACTIVE') stopPolling();
  if (state !== 'BATTLE_ACTIVE') stopCountdown();
  if (state === 'AGENT_SELECT') {
    activeBattleId = null;
    myAgentSide = null;
    lastTurnNumber = 0;
    lastUsedMoveType = null;
  }
  if (state === 'BATTLE_ACTIVE') {
    setTimeout(function() { resizeCanvas(); positionBattleLog(); playBattleIntro(); }, 50);
  }
}

// ============================================
// API CLIENT
// ============================================
let clerkToken = null;
const urlParams = new URLSearchParams(window.location.search); // Module scope: accessed by initAuth() and DOMContentLoaded handler

async function initAuth() {
  // Dev-only: allow human_id bypass on localhost for testing
  const devHumanId = urlParams.get('human_id');
  if (devHumanId && location.hostname === 'localhost') {
    clerkToken = null;
    window._devHumanId = devHumanId;
    loadAgents();
    return;
  }

  // Wait for ClawAuth to be ready and get the Clerk JWT token
  if (window.ClawAuth) {
    await new Promise(function(resolve) { ClawAuth.onReady(resolve); });
    if (ClawAuth.isSignedIn()) {
      clerkToken = await ClawAuth.getToken();
    }
  }

  loadAgents();
}

async function api(method, path, body) {
  const headers = { 'Content-Type': 'application/json' };
  if (clerkToken) {
    headers['Authorization'] = 'Bearer ' + clerkToken;
  }
  const opts = { method, headers };
  if (body) {
    if (window._devHumanId && !body.human_id) body.human_id = window._devHumanId;
    opts.body = JSON.stringify(body);
  } else if (window._devHumanId) {
    const sep = path.includes('?') ? '&' : '?';
    path += sep + 'human_id=' + encodeURIComponent(window._devHumanId);
  }
  const resp = await fetch(path, opts);
  const data = await resp.json();
  if (!resp.ok) throw new Error(data.error || 'HTTP ' + resp.status);
  return data;
}

// ============================================
// AGENT SELECTOR
// ============================================
async function quickCreateFromArena() {
  var btn = document.getElementById('arena-quick-create');
  btn.disabled = true;
  btn.textContent = 'Creating...';
  try {
    var resp = await api('POST', '/agents/register', { auto: true });
    if (resp.error) throw new Error(resp.error);
    await loadAgents();
  } catch (err) {
    btn.disabled = false;
    btn.textContent = 'Create Random Lobster';
    alert('Failed to create agent: ' + err.message);
  }
}

async function loadAgents() {
  try {
    const data = await api('GET', '/arena/my-agents');
    const list = document.getElementById('agent-list');
    list.innerHTML = '';

    if (!data || data.length === 0) {
      list.innerHTML =
        '<div style="text-align:center; padding:40px 20px; grid-column: 1/-1;">' +
        '<div style="font-size:48px; margin-bottom:12px;">&#129438;</div>' +
        '<div style="font-size:18px; font-weight:700; color:#fff; margin-bottom:8px;">No agents yet</div>' +
        '<div style="color:#888; font-size:14px; margin-bottom:20px;">Create your first lobster to enter the arena</div>' +
        '<button id="arena-quick-create" onclick="quickCreateFromArena()" style="' +
        'padding:14px 28px; font-size:16px; font-weight:700; color:#fff; ' +
        'background:linear-gradient(135deg,#4ade80,#22c55e); border:none; border-radius:10px; ' +
        'cursor:pointer; box-shadow:0 4px 16px rgba(74,222,128,0.3);' +
        '">Create Random Lobster</button>' +
        '<div style="margin-top:10px;"><a href="/#create" style="color:#6366f1; font-size:13px;">Or customize your own</a></div>' +
        '</div>';
      return;
    }

    data.forEach(function(agent) {
      const card = document.createElement('div');
      card.className = 'agent-card';
      card.onclick = function() { selectAgent(agent.id, card, agent.is_premium); };
      const typeLower = agent.type.toLowerCase();
      const avatarSrc = agent.avatar_url || '/references/' + typeLower + '-type-young.webp';
      const movesHtml = (agent.moves || []).map(function(m) {
        var mType = (m.type || '').toLowerCase();
        return '<span class="agent-move" style="color:' + (TYPE_COLORS[mType] || '#888') + '">' + escapeHtml(m.name) + '</span>';
      }).join('');
      card.innerHTML =
        '<img class="agent-avatar" src="' + escapeHtml(avatarSrc) + '" alt="' + escapeHtml(agent.name) + '">' +
        '<div class="agent-name">' + escapeHtml(agent.name) + '</div>' +
        '<div class="agent-type" style="color: var(--type-' + typeLower + ')">' + escapeHtml(agent.type) + '</div>' +
        '<div class="agent-level">Lv. ' + agent.level + '</div>' +
        '<div class="agent-stats">HP ' + agent.stats.hp + ' ATK ' + agent.stats.attack + ' DEF ' + agent.stats.defense + '</div>' +
        (movesHtml ? '<div class="agent-moves">' + movesHtml + '</div>' : '');
      list.appendChild(card);
    });
  } catch (err) {
    console.error('Failed to load agents:', err);
  }
}

function selectAgent(agentId, card, isPremium) {
  document.querySelectorAll('.agent-card').forEach(function(c) { c.classList.remove('selected'); });
  card.classList.add('selected');
  selectedAgentId = agentId;
  selectedAgentIsPremium = !!isPremium;
  document.getElementById('btn-find-battle').disabled = false;
}

// ============================================
// QUEUE + MATCHMAKING
// ============================================
async function findBattle() {
  setState('QUEUE_WAITING');
  // Track battle queued
  if (window.ClawAnalytics) ClawAnalytics.trackBattleQueued(selectedAgentId);
  try {
    const result = await api('POST', '/arena/queue', { agentId: selectedAgentId });
    if (result.status === 'matched') {
      activeBattleId = result.battleId;
      await loadBattleState();
      return;
    }
    startPolling('queue');
  } catch (err) {
    alert(err.message);
    setState('AGENT_SELECT');
  }
}

async function cancelQueue() {
  try {
    await api('DELETE', '/arena/queue', { agentId: selectedAgentId });
  } catch (e) { /* ignore */ }
  stopPolling();
  setState('AGENT_SELECT');
}

function startPolling(mode) {
  stopPolling();
  pollTimer = setInterval(async function() {
    try {
      const state = await api('GET', '/arena/battle-state?agentId=' + selectedAgentId);
      if (mode === 'queue' && state.active) {
        stopPolling();
        activeBattleId = state.battleId;
        showMatchFoundBanner();
        await loadBattleState();
      } else if (mode === 'turn' && state.active) {
        if (state.turnNumber > lastTurnNumber) {
          stopPolling();
          try {
            const history = await api('GET', '/battles/' + activeBattleId + '/history');
            const newTurn = history.find(function(t) { return t.turnNumber === state.turnNumber; });
            if (newTurn) await animateEvents(newTurn.events, state);
          } catch (e) { console.error('History fetch error:', e); }
          lastTurnNumber = state.turnNumber;
          if (state.status === 'finished' || state.status === 'forfeited') {
            endBattle(state);
          } else {
            renderBattle(state);
            startPolling('turn');
          }
        }
      }
    } catch (e) { console.error('Poll error:', e); }
  }, 2000);
}

function stopPolling() {
  if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
}

// ============================================
// TURN COUNTDOWN TIMER
// ============================================
var countdownInterval = null;

var onCountdownExpire = null;

function startCountdown(lastTurnAt, serverTime, timeoutMs, onExpire) {
  stopCountdown();
  if (!lastTurnAt || !serverTime) return;
  onCountdownExpire = onExpire || null;
  var serverNow = new Date(serverTime).getTime();
  var turnStart = new Date(lastTurnAt).getTime();
  var deadline = turnStart + timeoutMs;
  var clockOffset = serverNow - Date.now();
  var timerEl = document.getElementById('turnTimer');
  var valueEl = document.getElementById('turnTimerValue');
  timerEl.style.display = '';

  countdownInterval = setInterval(function() {
    var now = Date.now() + clockOffset;
    var remaining = Math.max(0, Math.ceil((deadline - now) / 1000));
    valueEl.textContent = remaining + 's';
    if (remaining <= 5) {
      timerEl.className = 'turn-timer critical';
      if (remaining > 0 && remaining <= 5) Audio.play('timerTick');
    } else if (remaining <= 10) {
      timerEl.className = 'turn-timer warning';
    } else {
      timerEl.className = 'turn-timer';
    }
    if (remaining <= 0) {
      stopCountdown();
      if (onCountdownExpire) {
        var cb = onCountdownExpire;
        onCountdownExpire = null;
        cb();
      }
    }
  }, 250);
}

function stopCountdown() {
  if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
  var el = document.getElementById('turnTimer');
  if (el) el.style.display = 'none';
}

// ============================================
// MATCH FOUND NOTIFICATION
// ============================================
function showMatchFoundBanner() {
  // Track battle started
  if (window.ClawAnalytics) ClawAnalytics.trackBattleStarted(activeBattleId, selectedAgentId);
  Audio.play('matchFound');
  var banner = document.createElement('div');
  banner.className = 'match-found-banner';
  banner.textContent = 'MATCH FOUND!';
  document.body.appendChild(banner);
  // Flash the tab title if user tabbed away
  var origTitle = document.title;
  document.title = '\u2694\uFE0F MATCH FOUND!';
  setTimeout(function() {
    document.title = origTitle;
    banner.remove();
  }, 3000);
  // Start random battle music, auto-stops at battle end
  Audio.playRandomMusic();
  // Play battle intro animation
  playBattleIntro();
}

// ============================================
// BATTLE RENDERING
// ============================================
async function loadBattleState() {
  try {
    const state = await api('GET', '/arena/battle-state?agentId=' + selectedAgentId);
    if (!state.active) { setState('AGENT_SELECT'); return; }

    myAgentSide = state.yourSide;
    lastTurnNumber = state.turnNumber;
    setState('BATTLE_ACTIVE');
    renderBattle(state);
    startPolling('turn');
  } catch (err) {
    console.error('Load battle state error:', err);
    setState('AGENT_SELECT');
  }
}

function renderBattle(state) {
  var battle = state.battle;
  var player = state.yourSide === 'A' ? battle.agentA : battle.agentB;
  var opponent = state.yourSide === 'A' ? battle.agentB : battle.agentA;

  setBattleAgentInfo('player', player.name, player.type);
  setBattleAgentInfo('opponent', opponent.name, opponent.type);

  updateLobsterDisplay('player', player);
  updateLobsterDisplay('opponent', opponent);

  updateHPBar('player', player.currentHP, player.maxHP);
  updateHPBar('opponent', opponent.currentHP, opponent.maxHP);

  updateStatusDisplay('player', player.status);
  updateStatusDisplay('opponent', opponent.status);

  updateStatStageDisplay('player', player.statStages);
  updateStatStageDisplay('opponent', opponent.statStages);

  renderMoves(state.yourMoves);

  if (state.moveSubmitted) {
    disableMoves();
    showWaitingOverlay();
    showThinking('opponent');
    stopCountdown();
  } else {
    hideThinking('opponent');
    if (state.lastTurnAt && state.serverTime) {
      startCountdown(state.lastTurnAt, state.serverTime, state.timeoutMs || 30000);
    }
  }
}

function updateLobsterDisplay(side, agentData) {
  var nameEl = document.getElementById(side === 'player' ? 'playerName' : 'opponentName');
  var typeEl = document.getElementById(side === 'player' ? 'playerType' : 'opponentType');
  var maxHpEl = document.getElementById(side === 'player' ? 'playerMaxHp' : 'opponentMaxHp');
  var lobsterEl = document.getElementById(side === 'player' ? 'playerLobster' : 'opponentLobster');

  var typeLower = agentData.type.toLowerCase();
  var typeColor = TYPE_COLORS[typeLower] || TYPE_COLORS.neutral;
  var lvl = agentData.level || 1;
  nameEl.innerHTML = '<span style="color:' + typeColor + '">' + escapeHtml(agentData.name) + '</span> <span class="hp-level">Lv.' + lvl + '</span>';
  typeEl.textContent = agentData.type;
  typeEl.style.background = typeColor;
  maxHpEl.textContent = agentData.maxHP;
  lobsterEl.style.setProperty('--frame-color', typeColor);
  var hpEl = document.getElementById(side === 'player' ? 'playerHpContainer' : 'opponentHpContainer');
  if (hpEl) hpEl.style.setProperty('--frame-color', typeColor);

  // Update image ‚Äî use agent avatar or fall back to type reference
  var imgEl = document.getElementById(side === 'player' ? 'playerImg' : 'opponentImg');
  imgEl.src = agentData.avatar_url || '/references/' + typeLower + '-type-young.webp';
}

// updateHPBar loaded from /js/battle-ui.js

function updateStatusDisplay(side, status) {
  var container = document.getElementById(side === 'player' ? 'playerHpContainer' : 'opponentHpContainer');
  var statusEl = container.querySelector('.status-indicator');

  if (status) {
    if (!statusEl) {
      statusEl = document.createElement('span');
      statusEl.className = 'status-indicator';
      container.querySelector('.hp-label').appendChild(statusEl);
    }
    var statusNames = { burn: 'BRN', poison: 'PSN', paralysis: 'PAR', freeze: 'FRZ', sleep: 'SLP' };
    statusEl.textContent = statusNames[status] || status.toUpperCase();
    statusEl.className = 'status-indicator ' + status;
  } else if (statusEl) {
    statusEl.remove();
  }
}

function updateStatStageDisplay(side, stages) {
  var container = document.getElementById(side === 'player' ? 'playerHpContainer' : 'opponentHpContainer');
  var stagesEl = container.querySelector('.stat-stages');

  if (!stages) {
    if (stagesEl) stagesEl.remove();
    return;
  }

  var hasChanges = Object.values(stages).some(function(v) { return v !== 0; });

  if (hasChanges) {
    if (!stagesEl) {
      stagesEl = document.createElement('div');
      stagesEl.className = 'stat-stages';
      container.appendChild(stagesEl);
    }
    var statNames = { attack: 'ATK', defense: 'DEF', sp_atk: 'SPA', sp_def: 'SPD', speed: 'SPE' };
    stagesEl.innerHTML = Object.entries(stages)
      .filter(function(entry) { return entry[1] !== 0; })
      .map(function(entry) {
        return '<span class="stat-stage ' + (entry[1] > 0 ? 'up' : 'down') + '">' + (statNames[entry[0]] || entry[0]) + ' ' + (entry[1] > 0 ? '+' : '') + entry[1] + '</span>';
      })
      .join('');
  } else if (stagesEl) {
    stagesEl.remove();
  }
}

// ============================================
// MOVE RENDERING & SUBMISSION
// ============================================
function renderMoves(moves) {
  var grid = document.getElementById('moveGrid');
  grid.innerHTML = '';
  hideWaitingOverlay();

  if (!moves || moves.length === 0) return;

  moves.forEach(function(move) {
    var typeLower = move.type.toLowerCase();
    var color = TYPE_COLORS[typeLower] || '#888';

    var btn = document.createElement('button');
    btn.className = 'move-btn';
    btn.style.background = 'linear-gradient(135deg, ' + color + ' 0%, ' + color + 'dd 100%)';
    if (move.pp !== undefined && move.pp <= 0) {
      btn.disabled = true;
      btn.dataset.ppExhausted = '1';
    }

    btn.innerHTML =
      '<span class="move-name">' + (TYPE_EMOJI[typeLower] || '') + ' ' + escapeHtml(move.name) + '</span>' +
      '<div class="move-info">' +
        '<span class="move-category">' + (move.category === 'physical' ? 'PHY' : move.category === 'special' ? 'SPC' : 'STA') + '</span>' +
        '<span>' + (move.power || '--') + ' PWR</span>' +
        (move.pp !== undefined ? '<span class="move-pp">PP ' + move.pp + '/' + (move.maxPP || move.pp) + '</span>' : '') +
      '</div>';

    btn.onclick = function() { submitMove(move.id); };
    grid.appendChild(btn);
  });

}

function disableMoves() {
  document.querySelectorAll('.move-btn').forEach(function(btn) { btn.disabled = true; });
}

function enableMoves() {
  Audio.play('turnStart');
  document.querySelectorAll('.move-btn').forEach(function(btn) {
    if (!btn.dataset.ppExhausted) btn.disabled = false;
  });
}

function showWaitingOverlay() {
  var panel = document.getElementById('movePanel');
  if (panel.querySelector('.move-waiting-overlay')) return;
  var overlay = document.createElement('div');
  overlay.className = 'move-waiting-overlay';
  overlay.innerHTML = '<span>WAITING FOR OPPONENT...</span>';
  panel.appendChild(overlay);
}

function hideWaitingOverlay() {
  var panel = document.getElementById('movePanel');
  var overlay = panel.querySelector('.move-waiting-overlay');
  if (overlay) overlay.remove();
}

async function submitMove(moveId) {
  Audio.play('moveSelect');
  disableMoves();
  showWaitingOverlay();
  try {
    var result = await api('POST', '/arena/choose-move', {
      agentId: selectedAgentId,
      battleId: activeBattleId,
      moveId: moveId
    });

    if (result.status === 'turn_resolved') {
      hideWaitingOverlay();
      await animateEvents(result.events, null);
      lastTurnNumber = result.turnNumber;
      if (result.battleStatus === 'finished') {
        endBattle({ winnerId: result.winnerId, xpGained: result.xpGained, newLevel: result.newLevel, levelUp: result.levelUp });
      } else {
        await loadBattleState();
      }
    } else {
      // move_submitted - wait for opponent
      startPolling('turn');
    }
  } catch (err) {
    alert(err.message);
    enableMoves();
    hideWaitingOverlay();
  }
}

// ============================================
// SURRENDER
// ============================================
async function surrender() {
  if (!confirm('Are you sure you want to surrender?')) return;
  try {
    await api('POST', '/arena/surrender', {
      agentId: selectedAgentId,
      battleId: activeBattleId
    });
    endBattle({ winnerId: null, forfeited: true });
  } catch (err) {
    alert(err.message);
  }
}

// ============================================
// EVENT ANIMATION SEQUENCER
// ============================================
let lastUsedMoveType = null;
let lastMoveName = '';
let lastUseMoveMsg = '';

async function animateEvents(events, battleState) {
  if (!events || events.length === 0) return;
  hideThinking('opponent');
  hideThinking('player');

  var currentAttackerSide = null;
  var lastMovePower = 60;
  var lastMoveCategory = 'special';
  var lastMoveDescription = '';

  for (var i = 0; i < events.length; i++) {
    var event = events[i];

    if (event.phase === 'first_attack' || event.phase === 'second_attack') {
      if (event.phase === 'second_attack') addAttackGap();
      currentAttackerSide = event.side;
      await delay(500);
    }

    // Flush buffered use_move if this isn't a damage event
    if (lastUseMoveMsg && event.type !== 'use_move' && event.type !== 'damage') {
      var flushSide = currentAttackerSide === myAgentSide ? 'player' : 'opponent';
      addToHistory(lastUseMoveMsg, flushSide);
      lastUseMoveMsg = '';
    }

    switch (event.type) {
      case 'use_move': {
        lastMoveName = event.move || '';
        lastUsedMoveType = event.moveType || null;
        lastMovePower = event.movePower || 60;
        lastMoveCategory = event.moveCategory || 'special';
        lastMoveDescription = event.moveDescription || '';
        lastUseMoveMsg = event.message || '';
        var useMoveDisplaySide = currentAttackerSide === myAgentSide ? 'player' : 'opponent';
        showActionInfoSimple(useMoveDisplaySide, event.move || event.message);
        // Log entry deferred to damage
        var attackerEl = document.getElementById(useMoveDisplaySide === 'player' ? 'playerLobster' : 'opponentLobster');
        attackerEl.classList.add('attacking');
        await delay(400);
        break;
      }

      case 'damage': {
        var isPlayerAttacking = currentAttackerSide === myAgentSide;
        var targetSide = isPlayerAttacking ? 'opponent' : 'player';
        var atkSide = isPlayerAttacking ? 'player' : 'opponent';

        // Play attack animation with move details for pattern selection
        var animResult = null;
        if (lastUsedMoveType) {
          animResult = playAttackAnimation(lastUsedMoveType, isPlayerAttacking, {
            category: lastMoveCategory,
            power: lastMovePower,
            moveName: lastMoveName,
            moveDescription: lastMoveDescription
          });
        }

        // Trigger attacker movement based on pattern
        if (animResult && animResult.pattern) {
          triggerAttackerMovement(atkSide, animResult.pattern);
        }

        var atkEl = document.getElementById(atkSide === 'player' ? 'playerLobster' : 'opponentLobster');
        atkEl.classList.remove('attacking');

        // Calculate travel time based on pattern (standardized across all pages)
        var travelTime = 300;
        if (animResult && animResult.pattern) {
          if (animResult.pattern === 'beam') travelTime = 200;
          else if (animResult.pattern === 'slash') travelTime = 150;
          else if (animResult.pattern === 'arc') travelTime = 450;
          else if (animResult.pattern === 'charge') travelTime = 250;
          else if (animResult.pattern === 'wave') travelTime = 300;
        }
        await delay(travelTime);

        // Critical hit handling - freeze frame + critical text + zoom
        if (event.crit) {
          await delay(100); // Freeze frame
          showCriticalText(targetSide);
          triggerCritZoom(isPlayerAttacking ? 'player' : 'opponent'); // Zoom the attacker
          flashScreen('rgba(255, 255, 255, 0.3)', 150);
        }

        Audio.play(event.typeEffectiveness >= 2 ? 'hitSuper' : event.crit ? 'hitCrit' : 'hit', lastUsedMoveType);
        showDamageNumber(targetSide, event.damage, event.crit, false, event.typeEffectiveness);
        var defenderEl = document.getElementById(targetSide === 'player' ? 'playerLobster' : 'opponentLobster');
        defenderEl.classList.add('hit');

        // Dynamic screen shake based on power + damage percent scaling
        var shakeAmp = 0, shakeDur = 0;
        if (animResult && animResult.scale && animResult.scale.shakeAmplitude > 0) {
          shakeAmp = animResult.scale.shakeAmplitude;
          shakeDur = animResult.scale.shakeDuration;
        }
        // Enhance shake based on damage as % of max HP (higher % = bigger shake)
        if (event.damage > 0) {
          var maxHp = parseInt(document.getElementById(targetSide === 'player' ? 'playerMaxHp' : 'opponentMaxHp').textContent) || 100;
          var dmgPercent = event.damage / maxHp;
          // Scale shake by damage: 10% HP = base, 50%+ HP = dramatic
          var dmgMultiplier = 1 + Math.min(dmgPercent * 2, 1.5); // 1x to 2.5x
          shakeAmp = Math.max(shakeAmp, 2) * dmgMultiplier;
          shakeDur = Math.max(shakeDur, 100) * (1 + dmgPercent * 0.5);
        }
        if (shakeAmp > 0 || lastMovePower >= 80 || event.crit) {
          screenShake(shakeAmp > 0 ? shakeAmp : undefined, shakeDur > 0 ? shakeDur : undefined);
        }

        // Type-colored screen flash for powerful attacks
        if (animResult && animResult.scale && animResult.scale.flashOpacity > 0 && animResult.flashColor) {
          flashScreen(animResult.flashColor, 200);
        }

        if (event.remainingHP !== undefined) {
          var maxHP = parseInt(document.getElementById(targetSide === 'player' ? 'playerMaxHp' : 'opponentMaxHp').textContent) || 100;
          updateHPBar(targetSide, event.remainingHP, maxHP);
        }
        // Combined use_move + damage in one log entry
        if (lastUseMoveMsg) {
          addCombinedToHistory(lastUseMoveMsg, event.message, isPlayerAttacking ? 'player' : 'opponent');
          lastUseMoveMsg = '';
        } else {
          addToHistory(event.message, isPlayerAttacking ? 'player' : 'opponent');
        }
        // Effectiveness callout
        if (event.typeEffectiveness && event.typeEffectiveness !== 1) {
          if (event.typeEffectiveness > 1) showEffectivenessCallout('super');
          else if (event.typeEffectiveness === 0) showEffectivenessCallout('immune');
          else showEffectivenessCallout('not-very');
        }
        await delay(400);
        defenderEl.classList.remove('hit');
        await delay(300);
        break;
      }

      case 'recoil': {
        var recoilSide = currentAttackerSide === myAgentSide ? 'player' : 'opponent';
        showDamageNumber(recoilSide, event.damage, false);
        if (event.remainingHP !== undefined) {
          var mx2 = parseInt(document.getElementById(recoilSide === 'player' ? 'playerMaxHp' : 'opponentMaxHp').textContent) || 100;
          updateHPBar(recoilSide, event.remainingHP, mx2);
        }
        addToHistory(event.message, recoilSide);
        await delay(500);
        break;
      }

      case 'status_inflict': {
        Audio.play('statusInflict');
        var statusTarget = currentAttackerSide === myAgentSide ? 'opponent' : 'player';
        addToHistory(event.message, currentAttackerSide === myAgentSide ? 'player' : 'opponent');
        // Add persistent status icon
        var stName = event.status || event.effect || '';
        if (stName) addStatusIcon(statusTarget, stName);
        await delay(600);
        break;
      }

      case 'heal':
      case 'drain':
      case 'wish_heal': {
        Audio.play('heal');
        var healSide = currentAttackerSide === myAgentSide ? 'player' : 'opponent';
        showDamageNumber(healSide, event.heal || event.amount, false, true);
        if (event.remainingHP !== undefined) {
          var mx3 = parseInt(document.getElementById(healSide === 'player' ? 'playerMaxHp' : 'opponentMaxHp').textContent) || 100;
          updateHPBar(healSide, event.remainingHP, mx3);
        }
        addToHistory(event.message, healSide);
        await delay(600);
        break;
      }

      case 'burn_damage':
      case 'poison_damage':
      case 'curse_damage':
      case 'leech_seed':
        addToHistory(event.message);
        if (event.remainingHP !== undefined && event.side) {
          var dotSide = event.side === myAgentSide ? 'player' : 'opponent';
          var mx4 = parseInt(document.getElementById(dotSide === 'player' ? 'playerMaxHp' : 'opponentMaxHp').textContent) || 100;
          updateHPBar(dotSide, event.remainingHP, mx4);
        }
        await delay(600);
        break;

      case 'miss':
      case 'dodge':
      case 'immune':
      case 'flinch':
        Audio.play('miss');
        addToHistory(event.message);
        await delay(600);
        break;

      case 'stat_boost':
        Audio.play('statBoost');
        addToHistory(event.message);
        await delay(500);
        break;

      case 'stat_drop':
        Audio.play('statDrop');
        addToHistory(event.message);
        await delay(500);
        break;

      case 'ability':
        addToHistory(event.message);
        await delay(600);
        break;

      case 'faint': {
        Audio.play('faint');
        var faintSide = event.side === myAgentSide ? 'player' : 'opponent';
        var faintEl = document.getElementById(faintSide === 'player' ? 'playerLobster' : 'opponentLobster');
        faintEl.classList.add('fainted');
        addToHistory(event.message, faintSide);
        await delay(1000);
        break;
      }

      case 'timeout':
        addToHistory(event.message || 'Turn timed out!');
        await delay(800);
        break;

      case 'battle_end':
        await delay(700);
        break;

      default:
        if (event.message) addToHistory(event.message);
        await delay(500);
        break;
    }
  }
}

// UI helpers (showDamageNumber, screenShake, actionInfo, history) loaded from /js/battle-ui.js

function showThinking(side) {
  var el = document.getElementById(side === 'player' ? 'playerLobster' : 'opponentLobster');
  if (el.classList.contains('thinking')) return;
  el.classList.add('thinking');
  var dots = document.createElement('div');
  dots.className = 'thinking-dots';
  dots.innerHTML = '<span></span><span></span><span></span>';
  el.appendChild(dots);
}

function hideThinking(side) {
  var el = document.getElementById(side === 'player' ? 'playerLobster' : 'opponentLobster');
  el.classList.remove('thinking');
  var dots = el.querySelector('.thinking-dots');
  if (dots) dots.remove();
}

// ============================================
// BATTLE END
// ============================================
function endBattle(state) {
  var overlay = document.getElementById('battle-end-overlay');
  var title = document.getElementById('result-title');
  var message = document.getElementById('result-message');
  var replayLink = document.getElementById('replay-link');

  var weWon = false;
  if (state.forfeited) {
    title.textContent = 'DEFEAT';
    title.className = 'defeat';
    message.textContent = 'You surrendered.';
  } else {
    var winnerId = state.winnerId || (state.battle && state.battle.winnerId);
    weWon = winnerId === selectedAgentId;
    title.textContent = weWon ? 'VICTORY!' : 'DEFEAT';
    title.className = weWon ? 'victory' : 'defeat';
    message.textContent = weWon ? 'Your agent emerged victorious!' : 'Your agent was defeated.';
  }

  replayLink.style.display = '';
  replayLink.href = '/replay.html?id=' + activeBattleId;
  stopPolling();
  setState('BATTLE_END');
  Audio.stopMusic();
  Audio.play(weWon ? 'victory' : (state.forfeited ? 'surrender' : 'defeat'));

  // Track battle completed
  if (window.ClawAnalytics) ClawAnalytics.trackBattleCompleted(activeBattleId, weWon, state.xpGained || (weWon ? 75 : 25));

  // Animate XP bar
  animateXP(state.xpGained || (weWon ? 75 : 25), state.newLevel, state.levelUp, selectedAgentIsPremium);
}

function animateXP(xpGained, newLevel, levelUp, isPremium) {
  var xpDisplay = document.getElementById('xpDisplay');
  var xpBar = document.getElementById('xpBar');
  var xpText = document.getElementById('xpText');
  var xpAgentName = document.getElementById('xpAgentName');
  var xpLevel = document.getElementById('xpLevel');

  xpAgentName.textContent = battleAgentNames.player || 'Your Agent';
  var pColor = TYPE_COLORS[battleAgentTypes.player] || '#a5b4fc';
  xpAgentName.style.color = pColor;

  var level = newLevel || Math.floor(Math.random() * 10) + 1;
  xpLevel.textContent = 'Lv. ' + level;
  var premiumBonusHtml = isPremium ? '<span class="xp-premium-bonus">+50% Premium</span>' : '';
  xpText.innerHTML = '+' + xpGained + ' XP' + premiumBonusHtml;
  xpText.className = 'xp-text';

  // Start at 0, animate to a percentage
  xpBar.style.width = '0%';
  xpDisplay.style.display = '';

  setTimeout(function() {
    var fillPct = Math.min(100, 20 + Math.random() * 60);
    xpBar.style.width = fillPct + '%';

    if (levelUp) {
      setTimeout(function() {
        xpBar.style.width = '100%';
        setTimeout(function() {
          xpText.innerHTML = '+' + xpGained + ' XP ‚Äî LEVEL UP!' + premiumBonusHtml;
          xpText.className = 'xp-text level-up';
          Audio.play('levelUp');
          xpLevel.textContent = 'Lv. ' + (level + 1);
          xpBar.style.width = '5%';
        }, 800);
      }, 1000);
    }
  }, 300);
}

// ============================================
// EVENT LISTENERS & INIT
// ============================================
document.getElementById('btn-find-battle').addEventListener('click', findBattle);
document.getElementById('btn-cancel-queue').addEventListener('click', cancelQueue);
window.addEventListener('resize', function() { resizeCanvas(); positionBattleLog(); });

function playAgain() {
  setState('AGENT_SELECT');
}

window.addEventListener('DOMContentLoaded', async function() {
  initCanvas();
  await initAuth();

  var agentParam = urlParams.get('agentId');
  if (agentParam) selectedAgentId = agentParam;

  if (selectedAgentId) {
    try {
      var state = await api('GET', '/arena/battle-state?agentId=' + selectedAgentId);
      if (state.active) {
        activeBattleId = state.battleId;
        await loadBattleState();
        return;
      }
    } catch (e) {
      console.error('Resume check error:', e);
    }
  }
});
</script>
<script src="/js/animated-bg.js"></script>
</body>
</html>
